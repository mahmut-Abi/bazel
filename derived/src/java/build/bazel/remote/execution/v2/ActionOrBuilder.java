// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: build/bazel/remote/execution/v2/remote_execution.proto

package build.bazel.remote.execution.v2;

public interface ActionOrBuilder extends
    // @@protoc_insertion_point(interface_extends:build.bazel.remote.execution.v2.Action)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The digest of the [Command][build.bazel.remote.execution.v2.Command]
   * to run, which MUST be present in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest command_digest = 1;</code>
   * @return Whether the commandDigest field is set.
   */
  boolean hasCommandDigest();
  /**
   * <pre>
   * The digest of the [Command][build.bazel.remote.execution.v2.Command]
   * to run, which MUST be present in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest command_digest = 1;</code>
   * @return The commandDigest.
   */
  build.bazel.remote.execution.v2.Digest getCommandDigest();
  /**
   * <pre>
   * The digest of the [Command][build.bazel.remote.execution.v2.Command]
   * to run, which MUST be present in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest command_digest = 1;</code>
   */
  build.bazel.remote.execution.v2.DigestOrBuilder getCommandDigestOrBuilder();

  /**
   * <pre>
   * The digest of the root
   * [Directory][build.bazel.remote.execution.v2.Directory] for the input
   * files. The files in the directory tree are available in the correct
   * location on the build machine before the command is executed. The root
   * directory, as well as every subdirectory and content blob referred to, MUST
   * be in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest input_root_digest = 2;</code>
   * @return Whether the inputRootDigest field is set.
   */
  boolean hasInputRootDigest();
  /**
   * <pre>
   * The digest of the root
   * [Directory][build.bazel.remote.execution.v2.Directory] for the input
   * files. The files in the directory tree are available in the correct
   * location on the build machine before the command is executed. The root
   * directory, as well as every subdirectory and content blob referred to, MUST
   * be in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest input_root_digest = 2;</code>
   * @return The inputRootDigest.
   */
  build.bazel.remote.execution.v2.Digest getInputRootDigest();
  /**
   * <pre>
   * The digest of the root
   * [Directory][build.bazel.remote.execution.v2.Directory] for the input
   * files. The files in the directory tree are available in the correct
   * location on the build machine before the command is executed. The root
   * directory, as well as every subdirectory and content blob referred to, MUST
   * be in the
   * [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Digest input_root_digest = 2;</code>
   */
  build.bazel.remote.execution.v2.DigestOrBuilder getInputRootDigestOrBuilder();

  /**
   * <pre>
   * A timeout after which the execution should be killed. If the timeout is
   * absent, then the client is specifying that the execution should continue
   * as long as the server will let it. The server SHOULD impose a timeout if
   * the client does not specify one, however, if the client does specify a
   * timeout that is longer than the server's maximum timeout, the server MUST
   * reject the request.
   * The timeout is a part of the
   * [Action][build.bazel.remote.execution.v2.Action] message, and
   * therefore two `Actions` with different timeouts are different, even if they
   * are otherwise identical. This is because, if they were not, running an
   * `Action` with a lower timeout than is required might result in a cache hit
   * from an execution run with a longer timeout, hiding the fact that the
   * timeout is too short. By encoding it directly in the `Action`, a lower
   * timeout will result in a cache miss and the execution timeout will fail
   * immediately, rather than whenever the cache entry gets evicted.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 6;</code>
   * @return Whether the timeout field is set.
   */
  boolean hasTimeout();
  /**
   * <pre>
   * A timeout after which the execution should be killed. If the timeout is
   * absent, then the client is specifying that the execution should continue
   * as long as the server will let it. The server SHOULD impose a timeout if
   * the client does not specify one, however, if the client does specify a
   * timeout that is longer than the server's maximum timeout, the server MUST
   * reject the request.
   * The timeout is a part of the
   * [Action][build.bazel.remote.execution.v2.Action] message, and
   * therefore two `Actions` with different timeouts are different, even if they
   * are otherwise identical. This is because, if they were not, running an
   * `Action` with a lower timeout than is required might result in a cache hit
   * from an execution run with a longer timeout, hiding the fact that the
   * timeout is too short. By encoding it directly in the `Action`, a lower
   * timeout will result in a cache miss and the execution timeout will fail
   * immediately, rather than whenever the cache entry gets evicted.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 6;</code>
   * @return The timeout.
   */
  com.google.protobuf.Duration getTimeout();
  /**
   * <pre>
   * A timeout after which the execution should be killed. If the timeout is
   * absent, then the client is specifying that the execution should continue
   * as long as the server will let it. The server SHOULD impose a timeout if
   * the client does not specify one, however, if the client does specify a
   * timeout that is longer than the server's maximum timeout, the server MUST
   * reject the request.
   * The timeout is a part of the
   * [Action][build.bazel.remote.execution.v2.Action] message, and
   * therefore two `Actions` with different timeouts are different, even if they
   * are otherwise identical. This is because, if they were not, running an
   * `Action` with a lower timeout than is required might result in a cache hit
   * from an execution run with a longer timeout, hiding the fact that the
   * timeout is too short. By encoding it directly in the `Action`, a lower
   * timeout will result in a cache miss and the execution timeout will fail
   * immediately, rather than whenever the cache entry gets evicted.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 6;</code>
   */
  com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder();

  /**
   * <pre>
   * If true, then the `Action`'s result cannot be cached, and in-flight
   * requests for the same `Action` may not be merged.
   * </pre>
   *
   * <code>bool do_not_cache = 7;</code>
   * @return The doNotCache.
   */
  boolean getDoNotCache();

  /**
   * <pre>
   * An optional additional salt value used to place this `Action` into a
   * separate cache namespace from other instances having the same field
   * contents. This salt typically comes from operational configuration
   * specific to sources such as repo and service configuration,
   * and allows disowning an entire set of ActionResults that might have been
   * poisoned by buggy software or tool failures.
   * </pre>
   *
   * <code>bytes salt = 9;</code>
   * @return The salt.
   */
  com.google.protobuf.ByteString getSalt();

  /**
   * <pre>
   * The optional platform requirements for the execution environment. The
   * server MAY choose to execute the action on any worker satisfying the
   * requirements, so the client SHOULD ensure that running the action on any
   * such worker will have the same result.  A detailed lexicon for this can be
   * found in the accompanying platform.md.
   * New in version 2.2: clients SHOULD set these platform properties as well
   * as those in the [Command][build.bazel.remote.execution.v2.Command]. Servers
   * SHOULD prefer those set here.
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Platform platform = 10;</code>
   * @return Whether the platform field is set.
   */
  boolean hasPlatform();
  /**
   * <pre>
   * The optional platform requirements for the execution environment. The
   * server MAY choose to execute the action on any worker satisfying the
   * requirements, so the client SHOULD ensure that running the action on any
   * such worker will have the same result.  A detailed lexicon for this can be
   * found in the accompanying platform.md.
   * New in version 2.2: clients SHOULD set these platform properties as well
   * as those in the [Command][build.bazel.remote.execution.v2.Command]. Servers
   * SHOULD prefer those set here.
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Platform platform = 10;</code>
   * @return The platform.
   */
  build.bazel.remote.execution.v2.Platform getPlatform();
  /**
   * <pre>
   * The optional platform requirements for the execution environment. The
   * server MAY choose to execute the action on any worker satisfying the
   * requirements, so the client SHOULD ensure that running the action on any
   * such worker will have the same result.  A detailed lexicon for this can be
   * found in the accompanying platform.md.
   * New in version 2.2: clients SHOULD set these platform properties as well
   * as those in the [Command][build.bazel.remote.execution.v2.Command]. Servers
   * SHOULD prefer those set here.
   * </pre>
   *
   * <code>.build.bazel.remote.execution.v2.Platform platform = 10;</code>
   */
  build.bazel.remote.execution.v2.PlatformOrBuilder getPlatformOrBuilder();
}
